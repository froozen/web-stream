package main

import (
	"github.com/bitly/go-simplejson"
	"github.com/froozen/go-helpers"
	"net/http"
	"os/exec"
	"strings"
	"time"
)

// ServeVideo serves an encoded video
func ServeVideo(w http.ResponseWriter, r *http.Request, name string) {
	// Only start encoding the file if it isn't already
	if NeedsEncode(name) {
		// Do the encoding in its own go routine, as
		// it will take a long time
		go func() {
			// Add the default input arg
			encodeArgs := []string{"-i", name}
			// Add the args from the config file
			encodeArgs = append(encodeArgs, args...)
			// Add the args generated by the hooks
			encodeArgs = append(encodeArgs, ExecuteHooks(name)...)
			// Add the default output gargs
			encodeArgs = append(encodeArgs, name+".webm")

			// Start the encoding
			err := exec.Command("ffmpeg", encodeArgs...).Run()
			helpers.ErrorCheck(err, "Encoding video")
		}()

		// Wait for a short time to allow for "buffering"
		time.Sleep(time.Duration(delay) * time.Second)
	}

	// Server the file
	http.ServeFile(w, r, name+".webm")
}

// FileQualifies determines wether a file qualifies for encoding
func FileQualifies(name string) bool {
	for _, suffix := range fileTypes {
		// If the file is of an valid filetype
		if strings.HasSuffix(name, suffix) {
			return true
		}
	}
	return false
}

// NeedsEncode determines wether a file needs encoding
func NeedsEncode(name string) bool {
	return !helpers.IsFile(name + ".webm")
}

// ExecuteHooks executes the hooks and returns the additional
// arguments generated by the hook-scripts
func ExecuteHooks(filename string) (additionalArgs []string) {
	for _, hook := range hooks {
		// Excecute the hook
		output, err := exec.Command(hook, filename).Output()
		helpers.ErrorCheck(err, "executing hook "+hook)

		// Parse the output
		json, err := simplejson.NewJson(output)
		helpers.ErrorCheck(err, "parsing "+hook+"'s output")

		// Append the new args
		additionalArgs = append(additionalArgs, StringSlice(json)...)
	}
	return
}
